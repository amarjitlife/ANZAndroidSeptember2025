
package learnKotlin


//_____________________________________________________________

// What Is Generics?
//      It's Code Which Will Generate Code
//      Code Template/Directive To Compiler To Generate Code 
//      Compile Time Polymorphism

//_____________________________________________________________

// Collection Is Type
//      Type Has Parameter <T>
//      Paramerized Type
//      Collection Is Paramaterized Type

//_____________________________________________________________

// Code Tempelate
//      Polymorphic Function
//          Using Mechanism Of Generics <T>
//          Using Mechanism Of Default Arguments
fun <T> Collection<T>.joinToStringFinal(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String {

    val result = StringBuilder( prefix )
    for ( ( index, element ) in this.withIndex() ) {
        if ( index > 0 ) result.append( separator )
        result.append( element)
    }

    result.append( postfix )
    return result.toString()
}

/*
//_____________________________________________________________
    // val numbers: List<Int> = listOf( 10, 20, 30, 40, 50 ) // List<Int>
    // <T> Place Holder To Be Sustituted With Integer Type
// Following Code Will Be Generated By Compiler
//      At Compile Time
fun <Integer> Collection<Integer>.joinToStringFinal(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String {

    val result = StringBuilder( prefix )
    for ( ( index, element ) in this.withIndex() ) {
        if ( index > 0 ) result.append( separator )
        result.append( element)
    }

    result.append( postfix )
    return result.toString()
}

//_____________________________________________________________
    // val names: List<String> = listOf( "Alice", "Martin", "Chandan", "Eshwari" ) // List<String>
    // // <T> Place Holder To Be Sustituted With String Type

fun <String> Collection<String>.joinToStringFinal(
    separator: String = ", ",
    prefix: String = "",
    postfix: String = ""
) : String {

    val result = StringBuilder( prefix )
    for ( ( index, element ) in this.withIndex() ) {
        if ( index > 0 ) result.append( separator )
        result.append( element)
    }

    result.append( postfix )
    return result.toString()
}
*/

//_____________________________________________________________

fun playWithJoinToStringFinal() {
    val numbers: List<Int> = listOf( 10, 20, 30, 40, 50 ) // List<Integer>
    // <T> Place Holder To Be Sustituted With Integer Type
    println( numbers.joinToStringFinal( " ; ", "( ", " )" ))
    println( numbers.joinToStringFinal() )
    println( numbers.joinToStringFinal( " ; " ))
    println( numbers.joinToStringFinal( " ; ", "( " ))

    val names: List<String> = listOf( "Alice", "Martin", "Chandan", "Eshwari" ) // List<String>
    // <T> Place Holder To Be Sustituted With String Type
    println( names.joinToStringFinal( " ; ", "( ", " )" ))
    println( names.joinToStringFinal() )
    println( names.joinToStringFinal( " ; " ))
    println( names.joinToStringFinal( " ; ", "( " ))
}

//_____________________________________________________________

// Can Write Extension Functions On <T> Placeholder
//          Argument Is Lambda Expression With Arugment Of T
fun <T> T.applyThenReturn( lamdbaExprn: (T) -> Unit ) : T {
    lamdbaExprn( this )
    return this
}

//          T Placeholder Act As Reciever Type For Lambda
//          Argument Is Lambda Expression With Reciever Of T
fun <T> T.applyThenReturnAgain( lamdbaExprnWithReceiver: T.() -> Unit ) : T {
    lamdbaExprnWithReceiver( this )
    return this
}

fun playWithExtensionFunction() {
    var name: String

    name = "Good Morning!".applyThenReturn( { some  -> println( some.uppercase() ) } )
    println( name )

    name = "Good Morning!".applyThenReturn { some  -> println( some.uppercase() ) } // Trailing Lambda Syntax
    println( name )

    println("\n.....")
    name = "Good Morning!".applyThenReturn { 
        some  -> some.uppercase() 
    } // Trailing Lambda Syntax
    println( name )

    name = "Good Morning!".applyThenReturn { 
        it.uppercase() 
    } // Trailing Lambda Syntax
    println( name )

    name = "Good Morning!".applyThenReturnAgain { 
        println( this.uppercase()  )
    } // Trailing Lambda Syntax
    println( name )

    name = "Good Morning!".applyThenReturnAgain { 
        println( uppercase()  )
    } // Trailing Lambda Syntax
    println( name )
}

//_____________________________________________________________

// <E> Type Placeholder Where Type Will Get Substituted By Compiler At Compile Time
//      Based On Usage

// Generic Class
//      Parametrised Type: MutableStack<E>

class MutableStack<E> ( vararg items: E ) {
    private val elements = items.toMutableList()
    fun push( element: E ) = elements.add( element )
    fun peek(): E = elements.last()
    fun pop(): E = elements.removeAt( elements.size - 1 )
    fun isEmpty() = elements.isEmpty()
    fun size() = elements.size
    override fun toString() = "MutableStack( ${elements.joinToString()})"
}

//_____________________________________________________________
// Compiler Generate Following Code
    // var stackInts = MutableStack<Int>( 10, 20, 30, 40, 50 )

/*
class MutableStack<Int> ( vararg items: Int ) {
    private val elements = items.toMutableList()
    fun push( element: Int ) = elements.add( element )
    fun peek(): Int = elements.last()
    fun pop(): Int = elements.removeAt( elements.size - 1 )
    fun isEmpty() = elements.isEmpty()
    fun size() = elements.size
    override fun toString() = "MutableStack( ${elements.joinToString()})"
}

    // var stackStrings = MutableStack<String>( "Alice", "Ding", "Trump", "Ketana")

class MutableStack<String> ( vararg items: String ) {
    private val elements = items.toMutableList()
    fun push( element: String ) = elements.add( element )
    fun peek(): String = elements.last()
    fun pop(): String = elements.removeAt( elements.size - 1 )
    fun isEmpty() = elements.isEmpty()
    fun size() = elements.size
    override fun toString() = "MutableStack( ${elements.joinToString()})"
}
*/

//_____________________________________________________________

fun playWithMutableStack() {
    // <E> Place Holder Have To Be Substitued With Int
    var stackInts = MutableStack<Int>( 10, 20, 30, 40, 50 )
    println( stackInts.size() )
    stackInts.push( 100 )
    stackInts.push( 200 )
    stackInts.push( 222 )
    println( stackInts.size() )
    println( stackInts.pop() )    

    var stackStrings = MutableStack<String>( "Alice", "Ding", "Trump", "Ketana")
    println( stackStrings.size() )
    stackStrings.push( "Ming" )
    stackStrings.push( "Mong" )
    println( stackStrings.size() )
    println( stackStrings.pop() )    
}


//_____________________________________________________________

// Function Type
//      (Int, Int) -> Int

// Function are Object Of Function Type
fun sum( x: Int, y: Int ) : Int = x + y
fun sub( x: Int, y: Int ) : Int = x - y

// Function Type
//      (Int, Int, (Int, Int) -> Int ) -> Int
// Polymorphic Function
//      Meachanism By Passing Behaviour To Behaviour
fun calculator( x: Int, y: Int, operation: (Int, Int) -> Int ) : Int {
    return operation( x, y )
}

// Polymorphic Function
//      Meachanism Using Function Overloading
fun calculator( x: Float, y: Float, operation: ( Float, Float) -> Float ) : Float {
    return operation( x, y )
}

// Parameterised Function Type
//      (T, T, (T, T) -> T ) -> T
// Polymorphic Function
//      Meachanism Using Generics
fun <T> calculatorAgain( x: T, y: T, operation: ( T, T ) -> T ) : T {
    return operation( x, y )
}

fun concat( x: String, y: String ) : String = x + y
fun concat2( x: String, y: String ) : String = x +  " ### " + y

fun playWithCalculator() {
    val x = 30
    val y = 20

    var result: Int 

    result = calculator(x, y, ::sum ) // ::sum Is Reference Of Sum Function
    println("Result : $result" )

    result = calculator(x, y, ::sub ) // ::sum Is Reference Of Sum Function
    println("Result : $result" )

    val result1 = calculatorAgain( "Ding", "Done", ::concat )
    println("Result : $result1" )

    val result2 = calculatorAgain( "Ding", "Done", ::concat2 )
    println("Result : $result2" )
}

//_____________________________________________________________
//_____________________________________________________________
//_____________________________________________________________
//_____________________________________________________________

fun main() {
    println("\nFunction: playWithJoinToStringFinal")
    playWithJoinToStringFinal()

    println("\nFunction: playWithExtensionFunction")
    playWithExtensionFunction()

    println("\nFunction: playWithMutableStack")
    playWithMutableStack()

    println("\nFunction: playWithCalculator")
    playWithCalculator()

    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
    // println("\nFunction: ")  
}


